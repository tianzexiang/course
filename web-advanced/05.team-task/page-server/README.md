# 基于cursor的分页查询

## 导入数据

```plain
node scripts/init.js
```

## skip-based分页

平时我们常用的分页方式都是基于 `skip/limit` 来实现的，类似下面的方式

```ts
const items = await db.records
  .find()
  .sort({ _id: -1 })
  .skip(10000)
  .limit(10)
  .toArray()
```

它的特点是：

- 全局分页，可以确定总分页条数
- 使用简单，直接使用自带的 `skip` 即可选择跳过的条数，返回指定页数的数据
- 数据量大、尤其是跳到比较靠后的页数时查询效率会急剧下降，因为数据库需要先查询 `skip` 的数据，页数越靠后，需要查询 `skip` 的数据也就越多、越耗时，以上面的代码为例，数据库需要先确定符合条件的前 `10000` 条记录，才能确定当前页的数据
- 当翻页时，如果前面的数据发生了变化，比如新增或删除了数据，那么翻到下一页时，就会出现数据不匹配的情况，比如重复看到了上一页的数据或者漏掉了没看到的数据

## cursor-based分页

还有另外一种基于 `cursor` （也可以称之为游标）的分页方式，示例如下

```ts
const items = await db.records
  .find({
    _id: {
      $lt: new ObjectId('62efd4d1d30f0d84e86b55b3')
    }
  })
  .sort({ _id: -1 })
  .limit(10)
  .toArray()
```

它的特点是：

- 局部分页，不能确定分页总数，因为它不关心前面满足条件的数据有多少条
- 实现复杂，需要自己设计查询过程
- 数据量大、跳到比较靠后的页数时查询效率不会有明显的降低，以上面的代码为例，数据库要查询当前页的时候会直接跳到 `ObjectId('62efd4d1d30f0d84e86b55b3')` 的位置开始往后查，而不需要关心前面满足条件的 `10000` 条记录是什么，**这里因为 `_id` 是创建了索引的，所以速度会很快，如果要基于其他的字段来查询如创建时间 `createdAt`，请确保该字段也创建了索引**
- 翻页时如果前面的数据发生了变化，比如新增或删除了数据，那么翻到下一页时不会产生影响，因为它不会影响游标

可以看到，这种方式更适合基于时间线的分页查询，比如FeedApp的首页信息流或者私信的聊天列表
